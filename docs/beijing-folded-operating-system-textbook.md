# 《北京折叠》作为操作系统教材

刘慈欣在《三体》系列里讨论的是宏观尺度的文明调度，而郝景芳的《北京折叠》则把镜头对准城市内部的阶层排布。故事里“折叠的北京”既是一座社会学景观，也是一台巨型的操作系统：它需要让几千万居民在有限的资源上轮换使用城市主体，靠复杂的规约维持秩序，又不断被现实中的离散事件扰动。把它当成操作系统教材来讲，能把抽象的概念变成具象的日常经验，让学生在情绪和逻辑之间来回切换。

## 1. 叙事设定即系统模型

- **硬件视角**：三层城市相当于三套互斥的硬件资源（CPU 时间片 + I/O 渠道 + 交通网络）。折叠与展开是系统的电源管理与功耗调度。
- **用户态与内核态**：普通居民的活动被限制在用户态，只有调度者、信息官等角色可以触碰“内核 API”，例如强制暂停地铁或提前展开城市。
- **异常与中断**：隧道塌陷、身份泄露、资源争夺等事件就是中断，需要抢占当前进程并执行异常处理例程。

把这些元素抽象出来，就能得到一个高层模型：`Universe = {state, rules, observers}`。其中 `state` 记录每一层的人口密度、能耗预算与交通负载；`rules` 是折叠节奏、夜班/日班切换的政策；`observers` 则是监督秩序的舆论与信息官。【F:src/compute_god/core/universe.py†L14-L170】

## 2. 调度：三班倒与公平性

### 2.1 周期性调度

- 每 24 小时的折叠-展开循环就是一个固定的时间片调度器，像 `round-robin` 一样保证所有层都有运行机会。
- 进入折叠状态时的“冻结”相当于把进程 swap 出内存，保存上下文，等待下一次时间片到来。
- 城市管理者需要估算上下文切换成本：折叠速度、能耗、交通重启的延迟，全都决定了下一轮调度的效率。

### 2.2 优先级与饥饿

- 第一空间拥有更高优先级，类似实时进程，它的时间片更长、服务质量更优。
- 第二空间是标准交互式进程，需要在用户体验和系统公平之间平衡。
- 第三空间的居民长期处于“饥饿”状态，教材可以引导学生设计 **老化机制**（aging）或 **多级反馈队列** 来提升最低层的响应度，讨论社会公平在调度算法中的实现。

## 3. 信息流视角：故事驱动的数据流编程

- **消息通道**：小说中的信息官网络与黑市消息贩子构成了异步消息通道，传递城市即将折叠的信号、身份验证数据和执法指令。
- **背压与拥塞控制**：信息传递过程中会出现拥堵（例如大量居民抢在折叠前返回），教材可以引导学生实现类似 TCP 的滑动窗口和拥塞避免策略。
- **一致性协议**：各层的折叠/展开必须保持一致状态，否则就会发生灾难。可以把这段故事抽象成一个需要达成一致的分布式协议（Raft/Paxos 级别），讨论消息丢失、恶意节点等问题。

结合 `compute_god.core.observer` 提供的事件追踪接口，可以让学生实现一个“信息流监控器”，观察各层之间的消息是否按序、是否出现阻塞。【F:src/compute_god/core/universe.py†L106-L170】

## 4. 存算分离：城市即数据中心

- **存储平面**：每一层的住宅区、地下仓库对应持久化存储，记录居民资产、生产资料、身份标识。
- **计算平面**：城市的生产活动、地铁运行、信息官决策对应计算节点，它们在展开的时间片里执行任务。
- **编排引擎**：折叠机制像 Kubernetes 调度器，负责把计算任务投放到当前展开的层。它必须遵守资源配额、负载均衡和隔离策略。

教材可以设计实验，让学生把 `compute_god.world` 模块里的 `WorldExecutionRequest` 当成任务描述，构造一个“折叠城市调度器”，在不同层间编排计算与存储交互。【F:src/compute_god/world.py†L14-L162】

## 5. 存储器层级：折叠结构的缓存比喻

- **一级缓存（L1）**：第一空间拥有最快的通道和最接近“核心”的资源，类似处理器的 L1 Cache，响应速度极快但容量有限。
- **二级缓存（L2）**：第二空间是城市主力，容量大、延迟适中。
- **三级缓存（L3/主存）**：第三空间容纳大量人口，但访问延迟高、带宽受限。
- **外存与归档**：折叠后被“存放”的层类似于休眠到磁盘，需要重新加载才能恢复活动。

通过这个比喻，学生能直观理解 **局部性原理** 和 **缓存一致性** 的重要性：如果折叠节奏频繁打断第一空间的使用，就像频繁的缓存失效，会导致整体吞吐量下降。

## 6. 教学活动设计

1. **案例讨论**：分析故事中某次调度失败（例如主人公被困在地下）的原因，画出状态机和时序图。
2. **模拟实验**：使用离散事件模拟（比如 Python 的 `asyncio` 或离散仿真框架）实现一个三层城市调度器，测量不同时间片长度对吞吐量与公平性的影响。
3. **调度算法 Hackathon**：让学生为第三空间设计新的调度策略（如动态时间片、补偿性配额），并用仿真数据评估“幸福度指数”。
4. **政策白皮书**：要求学生以操作系统工程师身份撰写建议书，说明为什么需要调整折叠周期或引入信息冗余机制。

## 7. 延伸阅读与实践

- 对照 `compute_god.threshold` 里的 **阈值动力学**，讨论政策阈值如何触发不同层的社会响应。【F:src/compute_god/threshold.py†L12-L154】
- 参考 `compute_god.rule_optimisation` 中的 **规则迭代器**，构建自动化调度策略，利用不动点方法寻找稳定制度。【F:src/compute_god/rule_optimisation.py†L12-L180】
- 联动 `docs/self-organization-gradient-descent.md`，引导学生思考社会系统如何通过局部规则实现全局稳定。

通过这样的教材编排，《北京折叠》不仅是一篇科幻小说，更是一次把操作系统抽象落地到社会系统的跨学科练习。学生在理解调度、信息流、存算分离与存储器层级的同时，也能体会技术选择与社会结构之间的张力。
