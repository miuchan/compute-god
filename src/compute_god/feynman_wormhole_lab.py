"""Translate simple Feynman diagrams into ER=EPR style bridge summaries.

The lab turns boundary-labelled Feynman diagrams into the data needed to
interpret them as Einstein–Rosen bridges.  Each leg is tagged as belonging
to the "left" or "right" boundary.  Propagators connect two legs and carry an
amplitude together with an optional proper-time factor.  The helper
:func:`run_feynman_wormhole_lab` accumulates these propagators into a matrix,
interprets the matrix as a bipartite state, and computes several diagnostics
that quantify the resulting wormhole throat:

* **Bridge strength** – the total absolute amplitude sewn between the two
  boundaries.
* **Schmidt spectrum** – singular values of the amplitude matrix normalised to
  act as the bridge's entanglement spectrum.
* **Entanglement entropy** – von Neumann entropy of the reduced density matrix,
  reported in bits via :func:`compute_god.self_application_er_epr.entanglement_entropy`.

The construction is intentionally compact so it can be imported in notebooks
or stitched into other universes as an observer.  It mirrors the discussion in
``self_application_er_epr`` where Feynman propagators, Choi states, and
Einstein–Rosen bridges are treated as different faces of the same process/state
correspondence.
"""

from __future__ import annotations

from dataclasses import dataclass
import math
from typing import Iterable, Sequence

try:  # pragma: no cover - exercised indirectly in environments without NumPy
    import numpy as np
except ImportError as exc:  # pragma: no cover - align with optional NumPy dep
    raise ImportError("compute_god.feynman_wormhole_lab requires numpy") from exc

from .self_application_er_epr import entanglement_entropy


@dataclass(frozen=True)
class DiagramLeg:
    """Label a diagram leg and assign it to a boundary."""

    label: str
    boundary: str

    def __post_init__(self) -> None:
        if self.boundary not in {"left", "right"}:
            raise ValueError("boundary must be either 'left' or 'right'")
        if not self.label:
            raise ValueError("leg label must be a non-empty string")


@dataclass(frozen=True)
class Propagator:
    """Connect two legs with an amplitude and optional proper time."""

    source: str
    target: str
    amplitude: float = 1.0
    proper_time: float = 1.0

    def weight(self, temperature: float) -> float:
        """Return the effective contribution after thermal suppression."""

        if self.proper_time < 0.0:
            raise ValueError("proper_time must be non-negative")
        return float(self.amplitude) * math.exp(-float(temperature) * float(self.proper_time))


@dataclass
class BridgeSummary:
    """Numerical diagnostics of the wormhole generated by a diagram."""

    left_labels: tuple[str, ...]
    right_labels: tuple[str, ...]
    temperature: float
    propagator_matrix: np.ndarray
    state_vector: np.ndarray
    schmidt_coefficients: tuple[float, ...]
    entanglement_bits: float
    bridge_strength: float

    def __post_init__(self) -> None:
        self.propagator_matrix = np.array(self.propagator_matrix, dtype=float, copy=True)
        self.state_vector = np.array(self.state_vector, dtype=float, copy=True)
        if self.temperature < 0.0:
            raise ValueError("temperature must be non-negative")


def _index_legs(legs: Sequence[DiagramLeg]) -> tuple[dict[str, DiagramLeg], list[str], list[str]]:
    registry: dict[str, DiagramLeg] = {}
    left: list[str] = []
    right: list[str] = []
    for leg in legs:
        if leg.label in registry:
            raise ValueError(f"duplicate leg label {leg.label!r}")
        registry[leg.label] = leg
        if leg.boundary == "left":
            left.append(leg.label)
        else:
            right.append(leg.label)
    if not left or not right:
        raise ValueError("diagram must contain at least one left and one right leg")
    return registry, left, right


def run_feynman_wormhole_lab(
    legs: Sequence[DiagramLeg],
    propagators: Iterable[Propagator],
    /,
    *,
    temperature: float = 1.0,
) -> BridgeSummary:
    """Return the entanglement profile induced by ``propagators``."""

    if temperature < 0.0:
        raise ValueError("temperature must be non-negative")

    registry, left_labels, right_labels = _index_legs(legs)
    left_index = {label: idx for idx, label in enumerate(left_labels)}
    right_index = {label: idx for idx, label in enumerate(right_labels)}

    matrix = np.zeros((len(left_labels), len(right_labels)), dtype=float)

    for propagator in propagators:
        try:
            source_leg = registry[propagator.source]
            target_leg = registry[propagator.target]
        except KeyError as error:
            raise KeyError(f"propagator references unknown leg {error.args[0]!r}") from None

        if source_leg.boundary == target_leg.boundary:
            raise ValueError("propagators must connect left and right boundaries")

        if source_leg.boundary == "left":
            left_label, right_label = source_leg.label, target_leg.label
        else:
            left_label, right_label = target_leg.label, source_leg.label

        weight = propagator.weight(temperature)
        matrix[left_index[left_label], right_index[right_label]] += weight

    state = matrix.reshape(-1)
    norm = float(np.linalg.norm(state))
    if norm == 0.0:
        raise ValueError("diagram produced a zero-amplitude bridge")

    normalised_state = state / norm
    entropy = float(entanglement_entropy(normalised_state, (len(left_labels), len(right_labels))))

    singular_values = np.linalg.svd(matrix, compute_uv=False)
    schmidt = tuple(float(value / norm) for value in singular_values if value / norm > 1e-12)

    bridge_strength = float(np.sum(np.abs(matrix)))

    return BridgeSummary(
        left_labels=tuple(left_labels),
        right_labels=tuple(right_labels),
        temperature=float(temperature),
        propagator_matrix=matrix,
        state_vector=normalised_state,
        schmidt_coefficients=schmidt,
        entanglement_bits=entropy,
        bridge_strength=bridge_strength,
    )


__all__ = [
    "DiagramLeg",
    "Propagator",
    "BridgeSummary",
    "run_feynman_wormhole_lab",
]
