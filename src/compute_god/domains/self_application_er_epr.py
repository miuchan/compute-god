"""Bridge self-application in λ-calculus with ER=EPR style glueing.

This module realises the conceptual dictionary from the prompt by
providing three complementary constructions:

* ``y_combinator`` – a direct implementation of the fixed-point
  combinator that turns higher-order processes into self-referential
  definitions.  The helper ``factorial_via_y`` shows how the semantic
  "loop" materialises in a concrete recursive calculation.
* ``thermofield_double`` – a numerical constructor for the
  thermo-field-double (TFD) state together with ``entanglement_entropy``
  to quantify the amount of EPR entanglement generated by the geometric
  "bridge" between the left and right Hilbert spaces.
* ``choi_state_from_kraus`` – an explicit Choi–Jamiołkowski transform
  that turns a quantum channel into a bipartite state.  This implements
  the process-state duality that underpins the analogy between feedback
  loops and Einstein–Rosen bridges.

The functions are intentionally lightweight, yet numerically precise,
so they can be imported in notebooks or used from unit tests to witness
the shared structure between self-application and wormholes.
"""

from __future__ import annotations

from typing import Callable, Iterable, Sequence, Tuple, TypeVar

import numpy as np

T = TypeVar("T")


def y_combinator(function: Callable[[Callable[..., T]], Callable[..., T]]) -> Callable[..., T]:
    """Return the fixed point of ``function`` via self-application.

    The implementation mirrors the classical, untyped λ-calculus
    definition ``Y = λg.(λx.g (x x)) (λx.g (x x))``.  The returned value
    is a callable that satisfies ``result = function(result)``.
    ``function`` is expected to be a higher-order constructor that
    accepts a recursive function and returns the first unfolding of the
    desired process.
    """

    def _self(applicator: Callable[..., T]) -> Callable[..., T]:
        return function(lambda *args: applicator(applicator)(*args))

    return _self(_self)


def factorial_via_y(n: int) -> int:
    """Compute ``n!`` using the :func:`y_combinator`.

    The recursive body is defined without self-reference; instead it
    receives the unfolding callable as an argument, which gets tied back
    to itself by :func:`y_combinator`.
    """

    if n < 0:
        raise ValueError("factorial is undefined for negative integers")

    def make_factorial(recursive: Callable[[int], int]) -> Callable[[int], int]:
        def inner(value: int) -> int:
            if value in (0, 1):
                return 1
            return value * recursive(value - 1)

        return inner

    factorial = y_combinator(make_factorial)
    return factorial(n)


def thermofield_double(energies: Sequence[float], beta: float) -> np.ndarray:
    """Construct the thermo-field-double state for a list of energies.

    ``energies`` enumerates the eigenvalues of the Hamiltonian for both
    the left and right systems.  ``beta`` is the inverse temperature.  The
    function returns a normalised state vector for the bipartite system
    in the computational basis ``|i⟩_L ⊗ |i⟩_R``.
    """

    spectrum = np.asarray(list(energies), dtype=float)
    if spectrum.ndim != 1 or spectrum.size == 0:
        raise ValueError("energies must be a one-dimensional, non-empty sequence")

    weights = np.exp(-0.5 * beta * spectrum)
    state = np.zeros((spectrum.size, spectrum.size), dtype=complex)
    np.fill_diagonal(state, weights)
    flattened = state.reshape(-1)
    norm = np.linalg.norm(flattened)
    if norm == 0.0:
        raise ValueError("thermofield double construction produced a zero vector")
    return flattened / norm


def entanglement_entropy(state: np.ndarray, dims: Tuple[int, int]) -> float:
    """Compute the von Neumann entropy ``S(ρ_A)`` for a pure bipartite state.

    ``state`` must be a flat state vector whose size matches ``dims``.
    The density matrix is traced over the second subsystem to obtain the
    reduced state ``ρ_A``.  The entropy is returned in bits.
    """

    dim_a, dim_b = dims
    if dim_a <= 0 or dim_b <= 0:
        raise ValueError("subsystem dimensions must be positive integers")

    vector = np.asarray(state, dtype=complex).reshape(dim_a * dim_b)
    density = np.outer(vector, np.conjugate(vector))
    density = density.reshape(dim_a, dim_b, dim_a, dim_b)
    reduced = np.zeros((dim_a, dim_a), dtype=complex)
    for j in range(dim_b):
        reduced += density[:, j, :, j]
    eigenvalues = np.linalg.eigvalsh((reduced + reduced.conj().T) / 2.0)
    eigenvalues = eigenvalues[eigenvalues > 1e-12]
    if eigenvalues.size == 0:
        return 0.0
    return float(-np.sum(eigenvalues * np.log2(eigenvalues)))


def choi_state_from_kraus(kraus_ops: Iterable[np.ndarray]) -> np.ndarray:
    """Return the Choi state associated with a quantum channel.

    The channel is specified by its Kraus operators ``A_k`` that satisfy
    ``∑_k A_k† A_k = I``.  The function returns the Choi matrix ``J`` of
    shape ``(dim_out * dim_in, dim_out * dim_in)`` computed via
    ``J = ∑_{ij} |i⟩⟨j| ⊗ Φ(|i⟩⟨j|)``.
    """

    operators = tuple(np.asarray(op, dtype=complex) for op in kraus_ops)
    if not operators:
        raise ValueError("at least one Kraus operator is required")

    first_shape = operators[0].shape
    if len(first_shape) != 2:
        raise ValueError("Kraus operators must be matrices")

    dim_out, dim_in = first_shape
    for op in operators:
        if op.shape != first_shape:
            raise ValueError("all Kraus operators must have the same dimensions")

    def apply_channel(operator: np.ndarray) -> np.ndarray:
        result = np.zeros((dim_out, dim_out), dtype=complex)
        for kraus in operators:
            result += kraus @ operator @ kraus.conj().T
        return result

    choi = np.zeros((dim_out, dim_in, dim_out, dim_in), dtype=complex)
    for i in range(dim_in):
        for j in range(dim_in):
            element = np.zeros((dim_in, dim_in), dtype=complex)
            element[i, j] = 1.0
            choi[:, i, :, j] = apply_channel(element)

    return choi.reshape(dim_out * dim_in, dim_out * dim_in)


def bell_state(dim: int) -> np.ndarray:
    """Return the maximally entangled Bell-like state for ``dim`` levels."""

    if dim <= 0:
        raise ValueError("dimension must be a positive integer")

    state = np.zeros((dim, dim), dtype=complex)
    np.fill_diagonal(state, 1.0)
    vector = state.reshape(-1)
    return vector / np.linalg.norm(vector)

