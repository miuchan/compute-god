"""Thermal dual observers affectionately known as ``机子`` and ``子机机``.

The project likes to give its helpers whimsical names.  ``Jizi`` (机子) tracks
the heat generated by an evolving universe, mirroring :class:`compute_god
.bingzi.Pingzi` but told from the perspective of an industrious machine.  Its
counterpart ``Zijiji`` (子机机) observes how cold a state can become, very much
like :class:`compute_god.bingzi.Bingzi`.  The pair intentionally mirrors one
another so that callers can reason about temperature ranges without having to
manually combine both observers.

To complete the story the module exposes :func:`thermal_dual` which calculates
the thermal gap and equilibrium point between the hottest state seen by the
machine and the coldest one encountered by the submachine.  The function
returns a tiny dataclass so that downstream code can inspect the numbers or
serialise them without additional ceremony.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Callable, List, MutableMapping, Optional, Tuple

from compute_god.core import ObserverEvent

State = MutableMapping[str, object]
TemperatureMetric = Callable[[State], float]


@dataclass
class Jizi:
    """Observer that keeps the hottest state a machine witnessed.

    Parameters
    ----------
    metric:
        Callable returning a temperature-like value for a state.  Larger values
        are considered hotter.
    boil_point:
        Threshold above which the machine is deemed overheated.  Defaults to
        ``100.0`` mirroring the boiling point of water in Celsius, but callers
        can freely choose whichever sentinel is meaningful for their domain.
    """

    metric: TemperatureMetric
    boil_point: float = 100.0
    history: List[Tuple[ObserverEvent, float]] = field(default_factory=list, init=False)
    hottest_value: Optional[float] = field(default=None, init=False)
    _hottest_state: Optional[State] = field(default=None, init=False, repr=False)

    def __call__(self, event: ObserverEvent, state: State, /, **metadata: object) -> None:
        """Record ``state`` together with the evaluated temperature."""

        temperature = float(self.metric(state))
        self.history.append((event, temperature))

        if self.hottest_value is None or temperature > self.hottest_value:
            self.hottest_value = temperature
            self._hottest_state = dict(state)

    @property
    def is_overheated(self) -> bool:
        """Return ``True`` once a temperature at or above ``boil_point`` is seen."""

        return self.hottest_value is not None and self.hottest_value >= self.boil_point

    def hottest_state(self) -> Optional[State]:
        """Return a defensive copy of the hottest state observed so far."""

        if self._hottest_state is None:
            return None
        return dict(self._hottest_state)

    def reset(self) -> None:
        """Clear the recorded history so the observer can be reused."""

        self.history.clear()
        self.hottest_value = None
        self._hottest_state = None


@dataclass
class Zijiji:
    """Observer that keeps the coldest state a submachine witnessed.

    Parameters
    ----------
    metric:
        Callable returning a temperature-like value for a state.  Smaller values
        are considered colder.
    freeze_point:
        Threshold under which the submachine is deemed frozen.  Defaults to
        ``0.0`` to match the freezing point of water in Celsius.
    """

    metric: TemperatureMetric
    freeze_point: float = 0.0
    history: List[Tuple[ObserverEvent, float]] = field(default_factory=list, init=False)
    coldest_value: Optional[float] = field(default=None, init=False)
    _coldest_state: Optional[State] = field(default=None, init=False, repr=False)

    def __call__(self, event: ObserverEvent, state: State, /, **metadata: object) -> None:
        """Record ``state`` together with the evaluated temperature."""

        temperature = float(self.metric(state))
        self.history.append((event, temperature))

        if self.coldest_value is None or temperature < self.coldest_value:
            self.coldest_value = temperature
            self._coldest_state = dict(state)

    @property
    def is_frozen(self) -> bool:
        """Return ``True`` once a temperature at or below ``freeze_point`` is seen."""

        return self.coldest_value is not None and self.coldest_value <= self.freeze_point

    def coldest_state(self) -> Optional[State]:
        """Return a defensive copy of the coldest state observed so far."""

        if self._coldest_state is None:
            return None
        return dict(self._coldest_state)

    def reset(self) -> None:
        """Clear the recorded history so the observer can be reused."""

        self.history.clear()
        self.coldest_value = None
        self._coldest_state = None


@dataclass(frozen=True)
class ThermalDual:
    """Summary describing the thermal duality between machine and submachine."""

    machine_heat: float
    submachine_cold: float
    gap: float
    equilibrium: float


def thermal_dual(machine: Jizi, submachine: Zijiji) -> Optional[ThermalDual]:
    """Compute the thermal duality between ``machine`` and ``submachine``.

    The function returns :class:`ThermalDual` once both observers have recorded
    at least one value.  Until then ``None`` is returned to signal that the
    comparison is not yet meaningful.
    """

    if machine.hottest_value is None or submachine.coldest_value is None:
        return None

    machine_heat = float(machine.hottest_value)
    submachine_cold = float(submachine.coldest_value)
    gap = machine_heat - submachine_cold
    equilibrium = (machine_heat + submachine_cold) / 2.0
    return ThermalDual(
        machine_heat=machine_heat,
        submachine_cold=submachine_cold,
        gap=gap,
        equilibrium=equilibrium,
    )


# Chinese aliases so callers can embrace the playful API if desired.
机子 = Jizi
日子 = Jizi
子机机 = Zijiji
月子 = Zijiji
热对偶 = thermal_dual
自机子对偶 = thermal_dual


__all__ = [
    "Jizi",
    "Zijiji",
    "ThermalDual",
    "thermal_dual",
    "机子",
    "日子",
    "子机机",
    "月子",
    "热对偶",
    "自机子对偶",
]

